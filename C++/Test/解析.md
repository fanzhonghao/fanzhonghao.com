----------------------------------
<h4>
创建时间
</h4>
<h5>这一示例表明：</h5>
<ul>
<li>全局变量优先于其它变量创建</li>

<li>全局变量也是最后才进行撤销</li>

<li>程序结束之后对象结构</li>

<li>程序结束，静态变量才撤销，要后于普通变量</li>

<li>析构顺序与构造顺序相反</li>

<li>然而当变量都是全局变量时，这时的构造和析构顺序只与代码顺序相关</li>

>例如：全局变量代码顺序为 A a; static A b;
>这时a,b依次构造，析构时顺序为： b , a.

</ul>
---------------------------------

---------------------------------
<h4>
Time
</h4>
<h5>这一示例表明：</h5>
<ul>
<li>构造函数要想赋予默认值时，在class内不能直接给变量赋值，除非你要直接实现
</ul>
---------------------------------

<h4>构造顺序</h4>
<h5>这一示例表明：</h5>
<ol>

<li> 如果子类没有定义构造方法，则调用父类的无参数的构造方法。</li>

<li> 如果子类定义了构造方法，不论是无参数还是带参数，在创建子类的对象的时候,首先执行父类无参数的构造方法，然后执行自己的构造方法。</li>

<li> 在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数，则会调用父类的默认无参构造函数。</li>

<li> 在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类自己提供了无参构造函数，则会调用父类自己的无参构造函数。</li>

<li>在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类只定义了自己的有参构造函数，则会出错（如果父类只有有参数的构造方法，则子类必须显示调用此带参构造方法）。</li>

<li>如果子类调用父类带参数的构造方法，需要用初始化父类成员对象的方式.</li>

</ol>
<h4>拷贝构造函数</h4>
<h5>
这一示例表明：
</h5>
<ul>
构造函数的写法为：
A (const A& a){*this = a;}
其中A为classname.
</ul>
----------------------------------
<h4>class_protected</h4>
<h5>这一示例用来探索派生中protected的用法</h5>
<ul>
<li>基类的对象不能直接访问基类的protected成员</li>
<li>在派生类内部直接访问protected成员和访问派生类对象基类的protected成员都是可行的</li>
<li>在派生的情况下，在类内部访问的protected和public没有区别</li>
<li>但是不能在类的外部直接访问protected成员</li>
</ul>
----------------------------------

----------------------------------
<h4>重载输出</h4>
<h5>将下列代码加入类中</h5>

friend ostream& operator<<(ostream& os,const (classname)& a){
    os << "what you want to print";
    return os;
    }

----------------------------------